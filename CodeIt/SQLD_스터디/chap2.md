# 챕터 2

## 정규화
### 정규화의 개념
- **<U>최소한의 데이터만을 하나의 엔티티에 넣는 식으로 데이터를 분해하는 과정</U>**
- 데이터의 중복을 제거, 데이터 모델의 독립성을 확보
- 이상현상을 줄이기 위한 데이터 베이스 설계 기법
- 논리 데이터 모델링 수행 시점에서 고려됨

### 이상현상
- 정규화를 하지 않아 발생하는 현상(삽입이상, 갱신이상, 삭제이상)

### 정규화 단계
1. 제 1 정규화(1NF)
  - 테이블의 컬럼이 원자성(한 속성이 하나의 값)을 갖도록 테이블 분해
  - 하나의 행과 하나의 컬럼에 하나의 값만 갖도록 하는 것

2. 제 2 정규화(2NF)
  - 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만들도록 테이블 분해
    - **완전 함수 종속** : <U>기본키를 구성하는 모든 컬럼의 값이 다른 컬럼을 결정짓는 상태</U>
  - 즉, <U><span style='color:pink'>PK가 2개 이상일 때</span> 발생하며 PK의 일부와 종속되는 관계가 있다면 분리한다.</U>

3. 제 3 정규화(3NF)
  - 제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분리
  - <U>이행적 종속성이란 A->B, B->C의 관계가 성립될 때 A->C가 성립되는 것을 말함</U>
  - (A,B)와 (B,C)로 분리하는 것이 제 3 정규화

4. BCNF(Boyce-Codd Normal Form) 정규화
  - 모든 결정자가 후보키가 되도록 테이블을 분해하는 것

5. 제 4 정규화
  - 여러 컬럼들이 하나의 컬럼을 종속시키는 경우 분해하여 다중값 종속성 제거

6. 제 5 정규화
  - 조인에 의해서 종속성이 발생되는 경우 분해

#### 반정규화=역정규화(De-Normalization)의 개념
  - 데이터베이스의 성능 향상을 위해 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법
  - 시스템 성능 향상, 개발 및 운영의 단순화를 위해 정규화된 데이터 모델을 중복, 통합, 분리하는 데이터 모델링 기법
  - 조회(select) 속도를 향상시키지만, 데이터 모델의 유연성은 낮아짐

> 비정규화를 언제?
  - 정규화에 충실하여 종속성, 활용성은 향상되지만 수행 속도가 느려지는 경우
  - 다량의 범위를 자주 처리해야 하는 경우
  - 특정 범위의 데이터만 자주 처리하는 경우
  - 요약/집계 정보가 자주 요구되는 경우

### 관계(relationship)의 개념
- <U>**엔티티의 인스턴스 사이의 논리적인 연관성**</U>
- 엔티티의 정의, 속성 정의 및 관계 정의에 따라서 변화할 수 있음
- **관계를 맺는다는 의미**는 부모의 식별자를 자식에 상속하고, 상속된 속성을 매핑키(조인키)로 활용   
-> 부모, 자식을 연결함

### 관계의 분류
- 관계는 존재에 의한 관계와 행위에 의한 관계로 분류
  - **<span style='color:pink'> 존재 관계</span>는 엔티티 간의 상태를 의미**
    - 사원은 부서에 속함

  - **<span style='color:pink'> 행위 관계</span>는 엔티티 간의 어떤 행위가 있는 것을 의미**
    - 주문은 고객이 주문할 때 발생

### 조인의 의미
- 데이터 중복을 피하기 위해 테이블은 정규화에 의해 분리됨
- 두 테이블의 데이터 동시에 출력하거나 관계가 있는 테이블 참조하기 위해서 데이터를 연결하는 과정
- **즉, 두 테이블 이상을 함께 보기 위해서 하는 과정**

### 계층형 데이터 모델
- **<U>자기 자신끼리 관계가 발생</U>** 즉, 하나의 엔티티 내의 인스턴스끼리 계층 구조를 가지는 경우를 의미
- 셀프조인 : 계층 구조를 갖는 인스턴스끼리 연결하는 조인

### 상호배타적 관계
- 두 테이블 중 하나만 가능한 관계

## 트랜잭션
### 트랜잭션이란?
  - **<U>하나의 연속적인 업무 단위를 말함</U>**
  - 트랜잭션에 의한 관계는 **필수적인 관계 형태**를 가짐
  - 하나의 트랜잭션에는 여러 select, insert, update 등이 포함됨

ex) A가 B고객에게 돈을 보내게 된다면
1. A에게 보내고자 하는 돈이 있는지 확인
2. A 계좌에서 -100 update
3. B 계좌에 +100 update

2,3 단계는 **반드시 동시에 일어나야함** -> 이런 연속적인 업무 단위 : 트랜잭션

### 주의 사항
1. 서로 독립적으로 발생 X
2. 부분 commit 불가

  > 즉, 두 가지가 같이 묶여서 행해져야 함

### 필수적, 선택적 관계와 ERD
- 두 엔티티의 관계가 서로 필수적일 때 하나의 트랜잭션을 형성
- 두 엔티티가 서로 독립적 수행이 가능하다면 선택적 관계

  IE 표기법)
    - 원을 사용하여 구분
    - 필수적 관계 원 x
    - 선택적 관계 원 o
  
  바커표기법)
    - 실선과 점선으로 구분
    - 필수적 관계 실선
    - 선택적 관계 점선

---

## NULL
### NULL 이란?
  - DBMS에서 <U>아직 정해지지 않은 값을 의미</U>
  - 0 과 빈문자열('')과는 다른 개념
  - 모델 설계 시 각 컬럼별로 NULL 허용 결정

### NULL의 특성
1. NULL을 포함한 연산 결과는 항상 NULL      
  >-> 즉, NULL 치환 후 연산해야함

2. 그룹 함수는 NULL 제외하고 연산을 수행
  - sum, avg, min, max 등 그룹 함수는 항상 NULL 무시하고 연산
  - count는 일반적으로 NULL이 아닌 값들의 수만 세지만, count(*)은 NULL 상관없이 모든 행 수 리턴

  >-> 즉, NULL의 유무로 AVG의 연산과 SUM/COUNT의 값이 다를 수 있음 

### NULL의 ERD 표기법
- IE 표기법에서는 NULL 허용여부를 알 수 있음
- 바커 표기법에서는 속성 앞에 동그라미가 NULL 허용 속성을 의미

---

## 식별자
### 식별자 구분(대체 여부에 딸른)

1) 본질식별자
  - 업무에 의해 만들어지는 식별자(꼭 필요한 식별자)

2) 인조식별자
  - 인위적으로 만들어지는 식별자(<U>꼭 필요하지 않지만 관리의 편의성 등의 이유로 인위적으로 만들어지는 식별자)</U>
  - 본질식별자가 복잡한 구성을 가질 때 인위적으로 생성
  - 주로 각 행을 구분하기 위한 기본키로 사용되며 자동으로 증가하는 일련번호 같은 형태

#### 인조식별자의 단점
  1. <span style='color:pink'>중복 데이터 발생</span> 가능성 -> 데이터 품질 저하
  2. <span style='color:pink'>불필요한 인덱스</span> 생성 -> 저장공간 낭비 및 DML 성능 저하

> 인덱스는 원래 조회 성능을 향상시키기 위한 객체이며, 인덱스는 DML(insert/update/delete)시 index split 현상으로 인해 성능이 저하된다.

  > 인덱스 스플릿이란?    
  데이터베이스에서 B-Tree 구조에서 인덱스를 관리할 때 발생하는 현상이다.
  인덱스 스플릿은 인덱스 페이지에 더 이상 데이터를 추가할 공간이 없을 때 페이지를 나누어 새로운 데이터를 삽입할 수 있도록 하는 작업 